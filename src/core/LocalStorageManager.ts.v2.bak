import { 
    FileSystemDirectoryHandle, 
    FileSystemFileHandle 
} from '../types/FileSystem';

// Constants for storage organization
const STORAGE_CONFIG_KEY = 'storage-config';
const DB_NAME = 'paper-reader-storage';
const DB_VERSION = 1;
const DB_STORE_NAME = 'handles';

const DATA_FOLDER = 'paper-reader-data';
const CACHE_FOLDER = 'cache';

interface StorageConfig {
    useFileSystem: boolean;
}

export class LocalStorageManager {
    private config: StorageConfig;
    private directoryHandle: FileSystemDirectoryHandle | null = null;
    private dbPromise: Promise<IDBDatabase> | null = null;

    constructor() {
        this.config = this.loadConfig();
        // Don't await in constructor, rely on init/restore call from App
    }

    // --- Initialization & Configuration ---

    private loadConfig(): StorageConfig {
        try {
            const stored = localStorage.getItem(STORAGE_CONFIG_KEY);
            if (stored) {
                return JSON.parse(stored);
            }
        } catch (e) {
            console.warn('Failed to load storage config', e);
        }
        return { useFileSystem: false };
    }

    private saveConfig() {
        try {
            localStorage.setItem(STORAGE_CONFIG_KEY, JSON.stringify(this.config));
        } catch (e) {
            console.error('Failed to save storage config', e);
        }
    }

    get isConnected(): boolean {
        return this.config.useFileSystem && this.directoryHandle !== null;
    }

    get needsReconnect(): boolean {
        return this.config.useFileSystem && this.directoryHandle === null;
    }

    // --- IDB Helpers for Handle Persistence ---

    private getDb(): Promise<IDBDatabase> {
        if (this.dbPromise) return this.dbPromise;

        this.dbPromise = new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            
            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve(request.result);
            
            request.onupgradeneeded = (event) => {
                const db = (event.target as IDBOpenDBRequest).result;
                if (!db.objectStoreNames.contains(DB_STORE_NAME)) {
                    db.createObjectStore(DB_STORE_NAME);
                }
            };
        });
        return this.dbPromise;
    }

    private async persistHandle(handle: FileSystemDirectoryHandle): Promise<void> {
        const db = await this.getDb();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(DB_STORE_NAME, 'readwrite');
            const store = tx.objectStore(DB_STORE_NAME);
            const request = store.put(handle, 'root-directory');
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
        });
    }

    private async retrieveHandle(): Promise<FileSystemDirectoryHandle | null> {
        try {
            const db = await this.getDb();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(DB_STORE_NAME, 'readonly');
                const store = tx.objectStore(DB_STORE_NAME);
                const request = store.get('root-directory');
                request.onsuccess = () => resolve(request.result || null);
                request.onerror = () => reject(request.error);
            });
        } catch (e) {
            // Database might not exist or other error
            console.warn('Error retrieving handle from IDB:', e);
            return null;
        }
    }

    // --- Directory Selection & Restoration ---

    /**
     * Attempts to restore the file system handle from IndexedDB.
     * Returns true if connection is active, false if permissions are needed or no handle exists.
     */
    async restoreDirectoryHandle(): Promise<boolean> {
        if (!this.config.useFileSystem) return false;

        const handle = await this.retrieveHandle();
        if (!handle) {
            this.config.useFileSystem = false; // Reset if handle is lost
            this.saveConfig();
            return false;
        }

        // Check if we already have permission
        try {
            const permission = await handle.queryPermission({ mode: 'readwrite' });
            if (permission === 'granted') {
                this.directoryHandle = handle;
                return true;
            }
        } catch (e) {
            console.warn('Error querying permission', e);
        }

        // We have the handle but need to ask permission again.
        return false;
    }

    /**
     * Called when user clicks "Reconnect" or "Grant Permission"
     */
    async reconnect(): Promise<boolean> {
        const handle = await this.retrieveHandle();
        if (!handle) return false;

        try {
            const permission = await handle.requestPermission({ mode: 'readwrite' });
            if (permission === 'granted') {
                this.directoryHandle = handle;
                this.config.useFileSystem = true;
                return true;
            }
        } catch (e) {
            console.error('Permission request failed or denied', e);
            alert('권한 요청이 거부되었거나 오류가 발생했습니다.');
        }
        return false;
    }

    /**
     * Primary entry point for user to pick a folder.
     */
    async requestDirectory(): Promise<boolean> {
        if (!('showDirectoryPicker' in window)) {
            alert('이 브라우저는 로컬 폴더 저장을 지원하지 않습니다. Chrome 또는 Edge를 사용하세요.');
            return false;
        }

        try {
            const handle = await window.showDirectoryPicker({
                mode: 'readwrite',
                startIn: 'documents'
            });

            this.directoryHandle = handle;
            this.config.useFileSystem = true;
            this.saveConfig();
            await this.persistHandle(handle);
            
            // Ensure data directories exist
            await this.ensureDataDirectories();

            return true;
        } catch (e: any) {
            if (e.name !== 'AbortError') {
                console.error('Directory picker error:', e);
                alert(`폴더 선택 실패: ${e.message}`);
            }
            return false;
        }
    }

    private async ensureDataDirectories() {
        if (!this.directoryHandle) return;
        try {
            const dataDir = await this.directoryHandle.getDirectoryHandle(DATA_FOLDER, { create: true });
            await dataDir.getDirectoryHandle(CACHE_FOLDER, { create: true });
            await this.directoryHandle.getDirectoryHandle('images', { create: true });
        } catch (e) {
            console.warn('Could not create data/cache struct', e);
        }
    }

    /**
     * Helper to navigate directory tree.
     * Use simple strings only. 'a' -> child 'a', 'a/b' -> child 'b' of 'a'.
     */
    private async resolveDirectory(path: string, create: boolean = false): Promise<FileSystemDirectoryHandle | null> {
        if (!this.directoryHandle) return null;
        let current = this.directoryHandle;
        if (!path || path === '.' || path === '/') return current;
        
        const parts = path.split('/').filter(p => p.length > 0 && p !== '.');
        
        try {
            for (const part of parts) {
                current = await current.getDirectoryHandle(part, { create });
            }
            return current;
        } catch {
            return null;
        }
    }

    // --- File Operations ---

    /**
     * List user's documents (HTML files) in the root.
     */
    async listFiles(extensions: string[] = ['.html', '.htm', '.md']): Promise<string[]> {
        const files: string[] = [];
        
        if (this.directoryHandle) {
            try {
                // @ts-ignore
                for await (const [name, handle] of this.directoryHandle.entries()) {
                    if (handle.kind === 'file') {
                        const lower = name.toLowerCase();
                        if (extensions.some(ext => lower.endsWith(ext))) {
                            files.push(name);
                        }
                    }
                }
            } catch (e) {
                console.warn('Error listing files', e);
            }
        } else {
            // LocalStorage fallback for legacy/demo mode
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key?.startsWith('cached-file:')) { // Matching FileSystem.ts legacy key
                    const name = key.replace('cached-file:', '').replace('/', ''); // simple strip
                    if (extensions.some(ext => name.toLowerCase().endsWith(ext))) {
                         files.push(name);
                    }
                }
            }
        }
        return files;
    }

    /**
     * Reads a file.
     * @param path Relative path from root. e.g., 'doc1.html' or 'paper-reader-data/settings.json'
     */
    async readFile(path: string): Promise<string | null> {
        // 1. Try File System
        if (this.directoryHandle) {
            try {
                const parts = path.split('/');
                const filename = parts.pop()!;
                const dirPath = parts.join('/');
                
                const dirHandle = await this.resolveDirectory(dirPath);
                if (dirHandle) {
                    const fileHandle = await dirHandle.getFileHandle(filename);
                    const file = await fileHandle.getFile();
                    return await file.text();
                }
            } catch (e) {
                // Ignore "not found"
            }
        }

        // 2. Try LocalStorage (Memory/Cache fallback)
        const lsKey1 = `cached-file:${path}`; 
        const lsKey2 = `data:${path}`;
        
        return localStorage.getItem(lsKey1) || localStorage.getItem(lsKey2) || null;
    }

    /**
     * Writes a file.
     * @param path Relative path from root.
     * @param content Content to write.
     */
    async writeFile(path: string, content: string): Promise<void> {
        // 1. Try File System
        if (this.directoryHandle) {
            try {
                const parts = path.split('/');
                const filename = parts.pop()!;
                const dirPath = parts.join('/');
                
                // Create directories if writing
                const dirHandle = await this.resolveDirectory(dirPath, true);
                if (dirHandle) {
                    const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    return; // Success
                }
            } catch (e) {
                console.error(`Failed to write file ${path} to FS`, e);
                // Don't throw, just log. We don't want to crash.
                return;
            }
        }

        // 2. LocalStorage Fallback (Only specific file types to avoid quota limits)
        if (path.endsWith('.json') || path.endsWith('.md')) { // Allow small text/config
             localStorage.setItem(`data:${path}`, content);
        }
    }

    // --- Specialized Helpers ---

    async saveJson<T>(filename: string, data: T, subfolder: string | null = DATA_FOLDER): Promise<void> {
        const path = subfolder ? `${subfolder}/${filename}` : filename;
        await this.writeFile(path, JSON.stringify(data, null, 2));
    }

    async loadJson<T>(filename: string, subfolder: string | null = DATA_FOLDER): Promise<T | null> {
        const path = subfolder ? `${subfolder}/${filename}` : filename;
        const text = await this.readFile(path);
        if (!text) return null;
        try {
            return JSON.parse(text) as T;
        } catch {
            return null;
        }
    }

    async saveCache(key: string, data: any): Promise<void> {
        // Saves to paper-reader-data/cache/key.json
        // Data in 'cache' is considered disposable (can be deleted to free space)
        await this.saveJson(key + '.json', data, `${DATA_FOLDER}/${CACHE_FOLDER}`);
    }

    async loadCache<T>(key: string): Promise<T | null> {
         return await this.loadJson<T>(key + '.json', `${DATA_FOLDER}/${CACHE_FOLDER}`);
    }

    /**
     * Delete all files in the cache folder.
     * Useful for freeing up space or resetting cached states.
     */
    async clearCache(): Promise<void> {
        if (!this.directoryHandle) return;

        try {
            const dataDir = await this.directoryHandle.getDirectoryHandle(DATA_FOLDER);
            try {
                // Try to remove the cache directory entirely
                await dataDir.removeEntry(CACHE_FOLDER, { recursive: true });
                // Recreate it empty
                await dataDir.getDirectoryHandle(CACHE_FOLDER, { create: true });
            } catch (e) {
                // Should only fail if it doesn't exist
            }
        } catch (e) {
            console.warn('Failed to clear cache', e);
        }
    }

    async loadFileAsUrl(relativePath: string): Promise<string | null> {
        if (!this.directoryHandle) return null;

        try {
            // Normalize path
            const normalizedPath = relativePath.replace(/\\/g, '/').replace(/^\.\//, '');
            const parts = normalizedPath.split('/');
            
            let currentDir = this.directoryHandle;
            
            // Navigate directories
            for (let i = 0; i < parts.length - 1; i++) {
                const dirName = parts[i];
                if (dirName === '' || dirName === '.') continue;
                currentDir = await currentDir.getDirectoryHandle(dirName, { create: false });
            }
            
            const fileName = parts[parts.length - 1];
            const fileHandle = await currentDir.getFileHandle(fileName, { create: false });
            const file = await fileHandle.getFile();
            return URL.createObjectURL(file);
        } catch (e) {
            return null;
        }
    }

    async saveImage(filename: string, blob: Blob): Promise<void> {
        if (this.directoryHandle) {
             const parts = filename.split('/');
             const name = parts.pop()!;
             try {
                const targetDir = await this.directoryHandle.getDirectoryHandle('images', { create: true });
                const fileHandle = await targetDir.getFileHandle(name, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(blob);
                await writable.close();
             } catch(e) {
                 console.error('Failed to save image', e);
             }
        }
        // No LS fallback for images to save space
    }
    
    // Helper for App to know current state
    getPathInfo(): string {
        return this.directoryHandle ? `로컬 폴더: ${this.directoryHandle.name}` : '브라우저 저장소 (임시)';
    }

    async deleteFile(path: string): Promise<void> {
        if (this.directoryHandle) {
             const parts = path.split('/');
             const name = parts.pop()!;
             const dirPath = parts.join('/');
             const dir = await this.resolveDirectory(dirPath);
             if (dir) {
                 await dir.removeEntry(name);
             }
        } else {
            localStorage.removeItem(`data:${path}`);
            localStorage.removeItem(`cached-file:${path}`);
        }
    }
}
